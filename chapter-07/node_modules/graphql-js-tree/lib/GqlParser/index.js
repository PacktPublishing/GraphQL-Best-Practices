"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGql = void 0;
const valueNode_1 = require("./valueNode");
const Models_1 = require("../Models");
const Parser_1 = require("../Parser");
const typeResolver_1 = require("../Parser/typeResolver");
const shared_1 = require("../shared");
const graphql_1 = require("graphql");
const parseGql = (gql, schema) => {
    const { definitions } = (0, graphql_1.parse)(schema + '\n' + gql, { noLocation: true });
    const ops = definitions.filter(onlyOperations);
    const frags = definitions.filter(onlyFragments);
    const { nodes } = Parser_1.Parser.parse(schema);
    const composeDefinition = (d) => {
        var _a, _b, _c, _d;
        const schemaNode = nodes.find((n) => n.data.type === Models_1.TypeSystemDefinition.SchemaDefinition);
        const operationField = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.args.find((a) => a.name === d.operation);
        if (!operationField) {
            console.log(JSON.stringify(schemaNode, null, 2));
            throw new Error(`Operation ${(_a = d.name) === null || _a === void 0 ? void 0 : _a.value} does not exist in schema`);
        }
        const operationType = (0, shared_1.getTypeName)(operationField.type.fieldType);
        const node = nodes.find((n) => n.name === operationType);
        if (!node) {
            throw new Error(`Operation ${(_b = d.name) === null || _b === void 0 ? void 0 : _b.value} does not exist in schema`);
        }
        return Object.assign(Object.assign(Object.assign({ name: (_c = d.name) === null || _c === void 0 ? void 0 : _c.value, node }, (d.operation
            ? {
                operation: d.operation === 'query'
                    ? Models_1.OperationType.query
                    : d.operation === 'mutation'
                        ? Models_1.OperationType.mutation
                        : Models_1.OperationType.subscription,
            }
            : {})), (((_d = d.variableDefinitions) === null || _d === void 0 ? void 0 : _d.length)
            ? {
                variableDefinitions: d.variableDefinitions.map((vd) => composeVariableDefinition(vd)),
            }
            : {})), { children: d.selectionSet.selections.map((s) => composeSelectionNode(s, node)) });
    };
    const composeFragment = (f) => {
        var _a;
        const node = nodes.find((n) => n.name == f.typeCondition.name.value);
        if (!node) {
            throw new Error(`Type ${f.typeCondition.name.value} does not exist in schema`);
        }
        return Object.assign(Object.assign({ node, fragment: true, name: f.name.value }, (((_a = f.directives) === null || _a === void 0 ? void 0 : _a.length) ? { directives: f.directives.map((a) => composeDirectiveNode(a, node)) } : {})), { children: f.selectionSet.selections.map((s) => composeSelectionNode(s, node)) });
    };
    const composeVariableDefinition = (v) => {
        const t = typeResolver_1.TypeResolver.resolveSingleFieldType(v.type);
        return {
            name: v.variable.name.value,
            type: (0, shared_1.compileType)(t),
        };
    };
    const composeArgumentNode = (a, parentNode) => {
        const node = parentNode.args.find((ar) => ar.name === a.name.value);
        if (!node) {
            throw new Error(`Invalid argument name ${a.name}`);
        }
        return {
            name: a.name.value,
            node,
            value: (0, valueNode_1.getValueWithoutLoc)(a.value),
        };
    };
    const composeDirectiveNode = (a, parentNode) => {
        var _a, _b;
        const node = parentNode.args.find((ar) => ar.name === a.name.value);
        if (!node) {
            throw new Error(`Invalid argument name ${a.name}`);
        }
        return Object.assign({ node, name: a.name.value }, (((_a = a.arguments) === null || _a === void 0 ? void 0 : _a.length) ? { arguments: (_b = a.arguments) === null || _b === void 0 ? void 0 : _b.map((ar) => composeArgumentNode(ar, node)) } : {}));
    };
    const composeFragmentSpread = (f, node) => {
        var _a, _b;
        return Object.assign(Object.assign({ node, name: f.name.value }, (((_a = f.directives) === null || _a === void 0 ? void 0 : _a.length) ? { directives: (_b = f.directives) === null || _b === void 0 ? void 0 : _b.map((a) => composeDirectiveNode(a, node)) } : {})), { fragmentSpread: true });
    };
    const composeInlineFragment = (f, node) => {
        var _a, _b;
        const chosenNode = nodes.find((n) => { var _a; return n.name === ((_a = f.typeCondition) === null || _a === void 0 ? void 0 : _a.name.value); });
        const rightNode = chosenNode || node;
        return Object.assign(Object.assign({ node: rightNode, name: rightNode.name }, (((_a = f.directives) === null || _a === void 0 ? void 0 : _a.length) ? { directives: (_b = f.directives) === null || _b === void 0 ? void 0 : _b.map((a) => composeDirectiveNode(a, rightNode)) } : {})), { inlineFragment: true, children: f.selectionSet.selections.map((s) => composeSelectionNode(s, rightNode)) });
    };
    const composeSelectionNode = (s, node) => {
        if (s.kind === 'Field')
            return composeFieldNode(s, node);
        if (s.kind === 'FragmentSpread')
            return composeFragmentSpread(s, node);
        return composeInlineFragment(s, node);
    };
    const composeFieldNode = (s, parentNode) => {
        var _a, _b, _c, _d, _e;
        const fieldNode = s.name.value === '__typename' ? (0, shared_1.createTypeNameField)() : parentNode.args.find((a) => a.name === s.name.value);
        if (!fieldNode) {
            throw new Error(`Field "${s.name.value}" does not exist in "${parentNode.name}" node`);
        }
        const passParentDown = (0, shared_1.getTypeName)(fieldNode.type.fieldType);
        const isParentObjectNode = nodes.find((n) => n.name === passParentDown &&
            (n.data.type === Models_1.TypeDefinition.ObjectTypeDefinition ||
                n.data.type === Models_1.TypeDefinition.UnionTypeDefinition ||
                n.data.type === Models_1.TypeDefinition.InterfaceTypeDefinition));
        return Object.assign(Object.assign(Object.assign({ node: fieldNode, name: s.name.value }, (((_a = s.arguments) === null || _a === void 0 ? void 0 : _a.length) ? { arguments: (_b = s.arguments) === null || _b === void 0 ? void 0 : _b.map((a) => composeArgumentNode(a, fieldNode)) } : {})), (((_c = s.directives) === null || _c === void 0 ? void 0 : _c.length) ? { directives: (_d = s.directives) === null || _d === void 0 ? void 0 : _d.map((a) => composeDirectiveNode(a, fieldNode)) } : {})), (((_e = s.selectionSet) === null || _e === void 0 ? void 0 : _e.selections.length)
            ? { children: s.selectionSet.selections.map((s) => composeSelectionNode(s, isParentObjectNode || fieldNode)) }
            : {}));
    };
    return [...frags.map((f) => composeFragment(f)), ...ops.map((o) => composeDefinition(o))];
};
exports.parseGql = parseGql;
const onlyOperations = (definition) => {
    return definition.kind === 'OperationDefinition';
};
const onlyFragments = (definition) => {
    return definition.kind === 'FragmentDefinition';
};
