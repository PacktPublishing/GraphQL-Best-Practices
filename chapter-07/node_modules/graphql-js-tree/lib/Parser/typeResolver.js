"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeResolver = void 0;
const Models_1 = require("../Models");
const Spec_1 = require("../Models/Spec");
const shared_1 = require("../shared");
const extractDefaultValueString_1 = require("./extractDefaultValueString");
class TypeResolver {
    static resolveSingleFieldType(n) {
        if (n.kind === 'ListType') {
            return {
                type: Models_1.Options.array,
                nest: TypeResolver.resolveSingleFieldType(n.type),
            };
        }
        if (n.kind === 'NonNullType') {
            return {
                type: Models_1.Options.required,
                nest: TypeResolver.resolveSingleFieldType(n.type),
            };
        }
        return {
            name: n.name.value,
            type: Models_1.Options.name,
        };
    }
    static iterateObjectTypeFields(fields) {
        return fields.map((n) => {
            const args = n.arguments ? TypeResolver.iterateInputValueFields(n.arguments) : [];
            return Object.assign(Object.assign({ name: n.name.value }, (n.description ? { description: n.description.value } : {})), { args, type: { fieldType: TypeResolver.resolveSingleFieldType(n.type) }, directives: n.directives ? TypeResolver.iterateDirectives(n.directives) : [], interfaces: [], data: {
                    type: Spec_1.TypeSystemDefinition.FieldDefinition,
                }, id: (0, shared_1.generateNodeId)(n.name.value, Spec_1.TypeSystemDefinition.FieldDefinition, args) });
        });
    }
    static resolveObjectField(f) {
        return [
            {
                name: f.name.value,
                type: {
                    fieldType: TypeResolver.resolveInputValueOptions(f.value, f.name.value),
                },
                data: {
                    type: Spec_1.Instances.Argument,
                },
                interfaces: [],
                directives: [],
                args: [],
                value: {
                    type: (0, Models_1.kindAsValue)(f.value.kind),
                    value: (0, extractDefaultValueString_1.extractDefaultValueString)(f.value),
                },
                id: (0, shared_1.generateNodeId)(f.name.value, Spec_1.Instances.Argument, []),
            },
        ];
    }
    static iterateDirectives(directives) {
        return directives.map((n) => {
            const args = n.arguments ? TypeResolver.iterateArgumentFields(n.arguments) : [];
            return {
                name: n.name.value,
                type: {
                    fieldType: {
                        name: n.name.value,
                        type: Models_1.Options.name,
                    },
                },
                directives: [],
                interfaces: [],
                data: {
                    type: Spec_1.Instances.Directive,
                },
                args,
                id: (0, shared_1.generateNodeId)(n.name.value, Spec_1.Instances.Directive, args),
            };
        });
    }
    static iterateArgumentFields(fields) {
        return fields.map((n) => {
            return {
                name: n.name.value,
                type: {
                    fieldType: TypeResolver.resolveInputValueOptions(n.value, n.name.value),
                },
                data: {
                    type: Spec_1.Instances.Argument,
                },
                directives: [],
                interfaces: [],
                value: {
                    type: (0, Models_1.kindAsValue)(n.value.kind),
                    value: (0, extractDefaultValueString_1.extractDefaultValueString)(n.value),
                },
                args: [],
                id: (0, shared_1.generateNodeId)(n.name.value, Spec_1.Instances.Argument, []),
            };
        });
    }
    static iterateInputValueFields(fields) {
        return fields.map((n) => {
            const value = n.defaultValue
                ? {
                    type: (0, Models_1.kindAsValue)(n.defaultValue.kind),
                    value: (0, extractDefaultValueString_1.extractDefaultValueString)(n.defaultValue),
                }
                : undefined;
            return Object.assign(Object.assign(Object.assign(Object.assign({ name: n.name.value }, (n.description ? { description: n.description.value } : {})), { directives: n.directives ? TypeResolver.iterateDirectives(n.directives) : [], type: { fieldType: TypeResolver.resolveSingleFieldType(n.type) }, data: {
                    type: Spec_1.ValueDefinition.InputValueDefinition,
                }, args: [], interfaces: [] }), (value ? { value } : {})), { id: (0, shared_1.generateNodeId)(n.name.value, Spec_1.ValueDefinition.InputValueDefinition, []) });
        });
    }
    static resolveInterfaces(n) {
        if (n.kind !== 'ObjectTypeDefinition' || !n.interfaces) {
            return;
        }
        return n.interfaces.map((i) => i.name.value);
    }
    static resolveFields(n) {
        if (n.kind === 'EnumTypeDefinition') {
            if (!n.values) {
                return;
            }
            return n.values.map((v) => (Object.assign(Object.assign({ name: v.name.value }, (v.description ? { description: v.description.value } : {})), { directives: v.directives ? TypeResolver.iterateDirectives(v.directives) : [], interfaces: [], args: [], type: { fieldType: { name: Spec_1.ValueDefinition.EnumValueDefinition, type: Models_1.Options.name } }, data: {
                    type: Spec_1.ValueDefinition.EnumValueDefinition,
                }, id: (0, shared_1.generateNodeId)(v.name.value, Spec_1.ValueDefinition.EnumValueDefinition, []) })));
        }
        if (n.kind === 'ScalarTypeDefinition') {
            return;
        }
        if (n.kind === 'UnionTypeDefinition') {
            if (!n.types) {
                return;
            }
            return n.types.map((t) => ({
                name: t.name.value,
                type: { fieldType: { name: t.name.value, type: Models_1.Options.name } },
                interfaces: [],
                args: [],
                directives: [],
                data: {
                    type: Spec_1.TypeSystemDefinition.UnionMemberDefinition,
                },
                id: (0, shared_1.generateNodeId)(t.name.value, Spec_1.TypeSystemDefinition.UnionMemberDefinition, []),
            }));
        }
        if (n.kind === 'InputObjectTypeDefinition') {
            if (!n.fields) {
                return;
            }
            const fields = TypeResolver.iterateInputValueFields(n.fields);
            return fields;
        }
        if (!n.fields) {
            return;
        }
        const fields = TypeResolver.iterateObjectTypeFields(n.fields);
        return fields;
    }
    static resolveFieldsFromDefinition(n) {
        if ('values' in n && n.values) {
            return n.values.map((v) => (Object.assign(Object.assign({ name: v.name.value, args: [], interfaces: [] }, (v.description ? { description: v.description.value } : {})), { directives: v.directives ? TypeResolver.iterateDirectives(v.directives) : [], type: { fieldType: { name: Spec_1.ValueDefinition.EnumValueDefinition, type: Models_1.Options.name } }, data: {
                    type: Spec_1.ValueDefinition.EnumValueDefinition,
                }, id: (0, shared_1.generateNodeId)(v.name.value, Spec_1.ValueDefinition.EnumValueDefinition, []) })));
        }
        if ('types' in n && n.types) {
            return n.types.map((t) => ({
                name: t.name.value,
                directives: [],
                args: [],
                interfaces: [],
                type: { fieldType: { name: t.name.value, type: Models_1.Options.name } },
                data: {
                    type: Spec_1.TypeSystemDefinition.UnionMemberDefinition,
                },
                id: (0, shared_1.generateNodeId)(t.name.value, Spec_1.TypeSystemDefinition.UnionMemberDefinition, []),
            }));
        }
        if ((n.kind === 'InputObjectTypeDefinition' || n.kind === 'InputObjectTypeExtension') && n.fields) {
            return TypeResolver.iterateInputValueFields(n.fields);
        }
        if ('arguments' in n && n.arguments) {
            return TypeResolver.iterateInputValueFields(n.arguments);
        }
        if (n.kind === 'ObjectTypeDefinition' ||
            n.kind === 'ObjectTypeExtension' ||
            n.kind === 'InterfaceTypeDefinition' ||
            n.kind === 'InterfaceTypeExtension') {
            if (!n.fields) {
                throw new Error('Type object should have fields');
            }
            return TypeResolver.iterateObjectTypeFields(n.fields);
        }
        return [];
    }
}
exports.TypeResolver = TypeResolver;
TypeResolver.resolveInputValueOptions = (value, name) => {
    if (value.kind === 'ListValue') {
        return {
            type: Models_1.Options.array,
            nest: {
                name,
                type: Models_1.Options.name,
            },
        };
    }
    return {
        name,
        type: Models_1.Options.name,
    };
};
