"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const graphql_1 = require("graphql");
const Models_1 = require("../Models");
const Spec_1 = require("../Models/Spec");
const typeResolver_1 = require("./typeResolver");
const ParserUtils_1 = require("./ParserUtils");
const shared_1 = require("../shared");
class Parser {
    static findComments(schema) {
        const stripDocs = schema
            .split(`"""`)
            .filter((e, i) => i % 2 !== 1)
            .join('');
        return stripDocs
            .split('\n')
            .filter((s) => s.trimStart().startsWith('#'))
            .map((s) => s.trimStart().slice(1).trimStart());
    }
}
exports.Parser = Parser;
Parser.importSchema = (schema) => (0, graphql_1.buildASTSchema)((0, graphql_1.parse)(schema));
Parser.documentDefinitionToSerializedNodeTree = (d) => {
    var _a, _b;
    if ((0, graphql_1.isTypeSystemDefinitionNode)(d) || (0, graphql_1.isTypeSystemExtensionNode)(d)) {
        const args = typeResolver_1.TypeResolver.resolveFieldsFromDefinition(d);
        const interfaces = 'interfaces' in d && d.interfaces ? d.interfaces.map((i) => i.name.value) : [];
        const directives = 'directives' in d && d.directives ? typeResolver_1.TypeResolver.iterateDirectives(d.directives) : [];
        if (d.kind === 'SchemaDefinition') {
            return {
                name: 'schema',
                args: d.operationTypes.map((ot) => (0, shared_1.createParserField)({
                    name: ot.operation,
                    data: {
                        type: Spec_1.TypeSystemDefinition.FieldDefinition,
                    },
                    type: {
                        fieldType: {
                            name: ot.type.name.value,
                            type: Models_1.Options.name,
                        },
                    },
                })),
                data: {
                    type: Spec_1.TypeSystemDefinition.SchemaDefinition,
                },
                directives: d.directives ? typeResolver_1.TypeResolver.iterateDirectives(d.directives) : [],
                id: (0, shared_1.generateNodeId)('schema', (0, Models_1.kindAsAllTypes)(d.kind), []),
                interfaces: [],
                type: {
                    fieldType: {
                        type: Models_1.Options.name,
                        name: 'schema',
                    },
                },
            };
        }
        if (d.kind === 'SchemaExtension') {
            return {
                name: 'schema',
                data: {
                    type: Spec_1.TypeSystemExtension.SchemaExtension,
                },
                directives: d.directives ? typeResolver_1.TypeResolver.iterateDirectives(d.directives) : [],
                interfaces: [],
                type: {
                    fieldType: {
                        type: Models_1.Options.name,
                        name: 'schema',
                    },
                },
                args: ((_a = d.operationTypes) === null || _a === void 0 ? void 0 : _a.map((ot) => (0, shared_1.createParserField)({
                    name: ot.operation,
                    data: {
                        type: Spec_1.TypeSystemDefinition.FieldDefinition,
                    },
                    type: {
                        fieldType: {
                            name: ot.type.name.value,
                            type: Models_1.Options.name,
                        },
                    },
                }))) || [],
                id: (0, shared_1.generateNodeId)('schema', (0, Models_1.kindAsAllTypes)(d.kind), []),
            };
        }
        return Object.assign(Object.assign({ name: d.name.value, type: d.kind === 'DirectiveDefinition'
                ? {
                    fieldType: { name: Models_1.TypeDefinitionDisplayMap[d.kind], type: Models_1.Options.name },
                    directiveOptions: d.locations.map((l) => l.value),
                }
                : {
                    fieldType: { name: Models_1.TypeDefinitionDisplayMap[d.kind], type: Models_1.Options.name },
                }, data: {
                type: (0, Models_1.kindAsAllTypes)(d.kind),
            } }, ('description' in d && ((_b = d.description) === null || _b === void 0 ? void 0 : _b.value) ? { description: d.description.value } : {})), { interfaces,
            directives,
            args, id: (0, shared_1.generateNodeId)(d.name.value, (0, Models_1.kindAsAllTypes)(d.kind), args) });
    }
};
Parser.parse = (schema, excludeRoots = [], libraries = '') => {
    var _a, _b, _c;
    let parsedSchema;
    const compiledSchema = [libraries, schema].join('\n');
    const isEmptySchema = compiledSchema.replace(/\s+/gm, '').length === 0;
    if (isEmptySchema) {
        return { nodes: [] };
    }
    try {
        parsedSchema = (0, graphql_1.parse)(compiledSchema);
    }
    catch (error) {
        if (compiledSchema.trim()) {
            console.error(error);
        }
    }
    if (!parsedSchema) {
        throw new Error('Cannot parse the schema');
    }
    const nodes = parsedSchema.definitions
        .filter((t) => t.kind === 'SchemaExtension' || t.kind === 'SchemaDefinition'
        ? true
        : 'name' in t && t.name && !excludeRoots.includes(t.name.value))
        .filter((t) => t.kind !== 'FragmentDefinition')
        .map((t) => Parser.documentDefinitionToSerializedNodeTree(t))
        .filter((d) => !!d);
    const comments = Parser.findComments(schema).map((description) => (0, shared_1.createParserField)({
        name: Spec_1.Helpers.Comment,
        type: {
            fieldType: {
                name: Spec_1.Helpers.Comment,
                type: Models_1.Options.name,
            },
        },
        data: {
            type: Spec_1.Helpers.Comment,
        },
        description,
    }));
    const nodeTree = {
        nodes: [...comments, ...nodes],
    };
    const allInterfaceNodes = nodeTree.nodes.filter((n) => n.data.type === Spec_1.TypeDefinition.InterfaceTypeDefinition);
    nodeTree.nodes.forEach((n) => {
        if (n.data.type === Spec_1.TypeDefinition.ObjectTypeDefinition ||
            n.data.type === Spec_1.TypeDefinition.InterfaceTypeDefinition) {
            if (n.interfaces) {
                const myInterfaces = allInterfaceNodes
                    .filter((interfaceNode) => n.interfaces.includes(interfaceNode.name))
                    .map((n) => ({
                    name: n.name,
                    argNames: n.args.map((a) => a.name),
                }));
                n.args = n.args.map((a) => {
                    const interfaceNames = myInterfaces
                        .filter((myInterface) => myInterface.argNames.includes(a.name))
                        .map((i) => i.name);
                    if (interfaceNames.length)
                        return Object.assign(Object.assign({}, a), { fromInterface: interfaceNames });
                    return a;
                });
            }
        }
    });
    const schemaNode = nodeTree.nodes.find((n) => n.data.type === Spec_1.TypeSystemDefinition.SchemaDefinition);
    if (!schemaNode) {
        const query = (_a = nodeTree.nodes.find((n) => n.name === 'Query')) === null || _a === void 0 ? void 0 : _a.name;
        const mutation = (_b = nodeTree.nodes.find((n) => n.name === 'Mutation')) === null || _b === void 0 ? void 0 : _b.name;
        const subscription = (_c = nodeTree.nodes.find((n) => n.name === 'Subscription')) === null || _c === void 0 ? void 0 : _c.name;
        if (query || mutation || subscription) {
            nodeTree.nodes.push((0, shared_1.createSchemaDefinition)({
                operations: {
                    query,
                    mutation,
                    subscription,
                },
            }));
        }
    }
    return nodeTree;
};
Parser.parseAddExtensions = (schema, excludeRoots = []) => {
    const parsed = Parser.parse(schema, excludeRoots);
    const Extensions = parsed.nodes.filter((n) => n.data.type && n.data.type in Spec_1.TypeExtension);
    if (!Extensions || Extensions.length === 0) {
        return parsed;
    }
    const nodes = parsed.nodes.filter((n) => !(n.data.type && n.data.type in Spec_1.TypeExtension));
    Extensions.forEach((e) => {
        const extendedNode = nodes.find((we) => ParserUtils_1.ParserUtils.isExtensionOf(e, we));
        if (!extendedNode) {
            throw new Error(`Invalid extension node`);
        }
        extendedNode.directives = [...(extendedNode.directives || []), ...e.directives];
        extendedNode.interfaces = [...(extendedNode.interfaces || []), ...e.interfaces];
        extendedNode.args = [...(extendedNode.args || []), ...e.args];
    });
    return { nodes };
};
__exportStar(require("./ParserUtils"), exports);
