"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkValueType = exports.mutate = void 0;
const Models_1 = require("../Models");
const shared_1 = require("../shared");
const directive_1 = require("./directive");
const interface_1 = require("./interface");
const shared_2 = require("./shared");
const mutate = (tree, allNodes) => {
    const mutateParentIfField = (node, parentNode) => {
        if (node.data.type === Models_1.TypeSystemDefinition.FieldDefinition) {
            const findParentNode = parentNode
                ? allNodes.find((n) => n.id === parentNode)
                : allNodes.find((an) => an.args.some((a) => a.id === node.id));
            if (!findParentNode)
                throw new Error('Invalid field definition');
            const fieldIndex = findParentNode.args.findIndex((a) => a.id == node.id);
            updateFieldOnNode(findParentNode, fieldIndex, node);
            return;
        }
    };
    const deleteFieldFromNode = (n, i) => {
        if (n.data.type === Models_1.TypeDefinition.InterfaceTypeDefinition) {
            const argName = n.args[i].name;
            tree.nodes
                .filter((filterNode) => filterNode.interfaces.includes(n.name))
                .forEach((nodeWithThisInterface) => {
                nodeWithThisInterface.args = nodeWithThisInterface.args
                    .map((a) => {
                    if (a.name !== argName || !a.fromInterface)
                        return a;
                    if (a.fromInterface.length === 1)
                        return null;
                    return Object.assign(Object.assign({}, a), { fromInterface: a.fromInterface.filter((ai) => ai !== n.name) });
                })
                    .filter(shared_2.filterNotNull);
            });
        }
        n.args.splice(i, 1);
        (0, shared_2.regenerateId)(n);
        mutateParentIfField(n);
    };
    const updateFieldOnNode = (node, i, updatedField, parentNode) => {
        (0, shared_2.regenerateId)(updatedField);
        if (node.data.type === Models_1.TypeSystemDefinition.DirectiveDefinition) {
            const oldField = JSON.parse(JSON.stringify(node.args[i]));
            (0, directive_1.recursivelyUpdateDirectiveArgument)(allNodes, node.name, oldField, updatedField, allNodes);
        }
        if (node.data.type === Models_1.TypeDefinition.InterfaceTypeDefinition) {
            const oldField = JSON.parse(JSON.stringify(node.args[i]));
            (0, interface_1.changeInterfaceField)(tree.nodes, node, oldField, updatedField);
        }
        node.args[i] = updatedField;
        (0, shared_2.regenerateId)(node);
        mutateParentIfField(node, parentNode);
    };
    const addFieldToNode = (node, f) => {
        var _a;
        (_a = node.args) === null || _a === void 0 ? void 0 : _a.push(Object.assign({}, f));
        if (node.data.type === Models_1.TypeDefinition.InterfaceTypeDefinition) {
            (0, interface_1.updateInterfaceNodeAddField)(tree.nodes, node);
        }
        (0, shared_2.regenerateId)(node);
        mutateParentIfField(node);
    };
    const renameRootNode = (node, newName) => {
        const isError = allNodes.map((n) => n.name).includes(newName);
        if (isError) {
            return;
        }
        if (node.data.type === Models_1.TypeSystemDefinition.DirectiveDefinition) {
            (0, directive_1.recursivelyRenameDirectiveNodes)(allNodes, node.name, newName);
        }
        if (node.data.type === Models_1.TypeDefinition.InterfaceTypeDefinition) {
            const oldName = node.name;
            tree.nodes
                .filter((n) => n.interfaces.includes(oldName))
                .forEach((n) => {
                n.interfaces = n.interfaces.filter((i) => i !== oldName).concat([newName]);
                n.args.forEach((a) => {
                    var _a;
                    a.fromInterface = (_a = a.fromInterface) === null || _a === void 0 ? void 0 : _a.filter((fi) => fi !== oldName).concat([newName]);
                });
                (0, shared_2.regenerateId)(n);
            });
        }
        (0, shared_2.ChangeAllRelatedNodes)({
            newName,
            nodes: tree.nodes,
            oldName: node.name,
        });
        node.name = newName;
        (0, shared_2.regenerateId)(node);
    };
    const removeNode = (node) => {
        if (node.data.type === Models_1.TypeSystemDefinition.FieldDefinition) {
            const parent = allNodes.find((parentNode) => parentNode.args.includes(node));
            if (parent) {
                const index = parent.args.indexOf(node);
                deleteFieldFromNode(parent, index);
            }
            return;
        }
        if (node.data.type === Models_1.TypeSystemDefinition.UnionMemberDefinition) {
            const parent = allNodes.find((parentNode) => parentNode.args.includes(node));
            if (parent) {
                const index = parent.args.indexOf(node);
                deleteFieldFromNode(parent, index);
            }
            return;
        }
        if (node.data.type === Models_1.ValueDefinition.InputValueDefinition) {
            const parent = allNodes.find((parentNode) => parentNode.args.includes(node));
            if (parent) {
                if (parent.data.type === Models_1.TypeSystemDefinition.DirectiveDefinition) {
                    (0, directive_1.recursivelyDeleteDirectiveArgument)(allNodes, parent.name, node);
                }
                const index = parent.args.indexOf(node);
                deleteFieldFromNode(parent, index);
            }
            else {
                const parent = allNodes.find((p) => p.args.some((a) => a.args.includes(node)));
                const field = parent === null || parent === void 0 ? void 0 : parent.args.find((a) => a.args.includes(node));
                if (field) {
                    const fieldIndex = field.args.findIndex((f) => f === node);
                    deleteFieldFromNode(field, fieldIndex);
                }
            }
            return;
        }
        if (node.data.type === Models_1.ValueDefinition.EnumValueDefinition) {
            const parent = allNodes.find((parentNode) => parentNode.args.includes(node));
            if (parent) {
                const index = parent.args.indexOf(node);
                deleteFieldFromNode(parent, index);
            }
            return;
        }
        if (node.data.type === Models_1.Instances.Directive) {
            throw new Error('Directive Instances should be removed on node directly not using this function');
        }
        if (node.data.type === Models_1.Instances.Argument) {
            throw new Error('Directive Instance Arguments should be removed on node directly not using this function');
        }
        if (node.data.type === Models_1.TypeSystemDefinition.DirectiveDefinition) {
            (0, directive_1.recursivelyDeleteDirectiveNodes)(allNodes, node.name);
        }
        const deletedNode = tree.nodes.findIndex((n) => n === node);
        if (deletedNode === -1)
            throw new Error('Error deleting a node');
        if (node.data.type === Models_1.TypeExtension.InterfaceTypeExtension) {
        }
        tree.nodes.splice(deletedNode, 1);
        (0, shared_2.RemoveRelatedExtensionNodes)({ node, tree });
        tree.nodes.forEach((n) => {
            n.args = n.args
                .filter((a) => {
                const tName = (0, shared_1.getTypeName)(a.type.fieldType);
                if (tName === node.name && !(0, shared_2.isExtensionNode)(node.data.type)) {
                    return null;
                }
                return a;
            })
                .filter(shared_2.filterNotNull);
            (0, shared_2.regenerateId)(n);
        });
        if (node.data.type === Models_1.TypeDefinition.InterfaceTypeDefinition) {
            tree.nodes
                .filter((n) => n.interfaces.includes(node.name))
                .forEach((n) => {
                deImplementInterface(n, node.name);
            });
        }
    };
    const implementInterface = (node, interfaceNode) => {
        var _a, _b;
        const interfacesToPush = (0, interface_1._getAllConnectedInterfaces)(allNodes, [interfaceNode.name]);
        node.interfaces.push(...interfacesToPush);
        const argsToPush = ((_a = interfaceNode.args) === null || _a === void 0 ? void 0 : _a.filter((a) => { var _a; return !((_a = node.args) === null || _a === void 0 ? void 0 : _a.find((na) => na.name === a.name)); })) || [];
        node.args = node.args.map((a) => {
            if (interfaceNode.args.find((interfaceArg) => interfaceArg.name === a.name)) {
                return Object.assign(Object.assign({}, a), { fromInterface: (a.fromInterface || []).concat([interfaceNode.name]) });
            }
            return a;
        });
        node.args = (_b = node.args) === null || _b === void 0 ? void 0 : _b.concat(argsToPush.map((atp) => (Object.assign(Object.assign({}, atp), { fromInterface: [interfaceNode.name] }))));
        (0, shared_2.regenerateId)(node);
    };
    const deImplementInterface = (node, interfaceName) => {
        const interfacesToDeImplement = (0, interface_1._getAllConnectedInterfaces)(allNodes, [interfaceName]);
        node.interfaces = node.interfaces.filter((ni) => !interfacesToDeImplement.includes(ni));
        node.args = node.args
            .map((a) => {
            var _a;
            if (!((_a = a.fromInterface) === null || _a === void 0 ? void 0 : _a.length))
                return a;
            a.fromInterface = a.fromInterface.filter((fi) => !interfacesToDeImplement.includes(fi));
            if (a.fromInterface.length === 0)
                return null;
            return a;
        })
            .filter(shared_2.filterNotNull);
        (0, shared_2.regenerateId)(node);
    };
    const setValueNode = (node, value) => {
        node.value = {
            value,
            type: (0, exports.checkValueType)(node, allNodes),
        };
    };
    const removeAllDirectives = () => {
        (0, directive_1.recursivelyDeleteAllDirectiveNodes)(allNodes);
    };
    return {
        updateFieldOnNode,
        addFieldToNode,
        renameRootNode,
        removeNode,
        implementInterface,
        deImplementInterface,
        setValueNode,
        removeAllDirectives,
    };
};
exports.mutate = mutate;
const checkValueType = (node, nodes) => {
    const isArray = (0, shared_2.isArrayType)(node.type.fieldType);
    if (isArray)
        return Models_1.Value.ListValue;
    const tName = (0, shared_1.getTypeName)(node.type.fieldType);
    const scalarTypes = nodes.filter((n) => n.data.type === Models_1.TypeDefinition.ScalarTypeDefinition).map((n) => n.name);
    if ((0, shared_2.isScalarArgument)(node, scalarTypes)) {
        if (tName === Models_1.ScalarTypes.Boolean) {
            return Models_1.Value.BooleanValue;
        }
        if (tName === Models_1.ScalarTypes.Float) {
            return Models_1.Value.FloatValue;
        }
        if (tName === Models_1.ScalarTypes.ID) {
            return Models_1.Value.IDValue;
        }
        if (tName === Models_1.ScalarTypes.Int) {
            return Models_1.Value.IntValue;
        }
        if (tName === Models_1.ScalarTypes.String) {
            return Models_1.Value.StringValue;
        }
        return Models_1.Value.ScalarValue;
    }
    const parentNode = nodes.find((n) => n.name === tName);
    if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.data.type) === Models_1.TypeDefinition.InputObjectTypeDefinition ||
        (parentNode === null || parentNode === void 0 ? void 0 : parentNode.data.type) === Models_1.TypeExtension.InputObjectTypeExtension) {
        return Models_1.Value.ObjectValue;
    }
    if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.data.type) === Models_1.TypeDefinition.EnumTypeDefinition ||
        (parentNode === null || parentNode === void 0 ? void 0 : parentNode.data.type) === Models_1.TypeExtension.EnumTypeExtension) {
        return Models_1.Value.EnumValue;
    }
    return Models_1.Value.Variable;
};
exports.checkValueType = checkValueType;
