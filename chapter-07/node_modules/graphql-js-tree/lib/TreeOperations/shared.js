"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArrayType = exports.isScalarArgument = exports.RemoveRelatedExtensionNodes = exports.ChangeAllRelatedNodes = exports.ChangeRelatedNode = exports.regenerateId = exports.isExtensionNode = exports.resolveValueFieldType = exports.changeNodeOptions = exports.changeTypeName = exports.filterNotNull = void 0;
const Models_1 = require("../Models");
const shared_1 = require("../shared");
function filterNotNull(t) {
    return t !== null;
}
exports.filterNotNull = filterNotNull;
const changeTypeName = (field, newName) => {
    const changeFieldName = (field, newName) => {
        if (field.type === Models_1.Options.array) {
            return changeFieldName(field.nest, newName);
        }
        else if (field.type === Models_1.Options.required) {
            return changeFieldName(field.nest, newName);
        }
        field.name = newName;
    };
    changeFieldName(field, newName);
    return field;
};
exports.changeTypeName = changeTypeName;
const changeNodeOptions = (field, newOption) => {
    const changeOptions = (field, newOption) => {
        if (field.type !== Models_1.Options.array && newOption === Models_1.Options.array) {
            if (field.type === Models_1.Options.required) {
            }
            changeOptions(field, Models_1.Options.array);
        }
        else if (field.type !== newOption && newOption === Models_1.Options.required) {
            changeOptions(field, Models_1.Options.required);
        }
        field.type = Models_1.Options.name;
    };
    changeOptions(field, newOption);
    return field;
};
exports.changeNodeOptions = changeNodeOptions;
const resolveValueFieldType = (name, fType, isRequired = false, fn = (x) => x) => {
    if (fType.type === Models_1.Options.name) {
        return fn(isRequired ? name : `${name} | undefined | null`);
    }
    if (fType.type === Models_1.Options.array) {
        return (0, exports.resolveValueFieldType)(name, fType.nest, false, isRequired ? (x) => `Array<${fn(x)}>` : (x) => `Array<${fn(x)}> | undefined | null`);
    }
    if (fType.type === Models_1.Options.required) {
        return (0, exports.resolveValueFieldType)(name, fType.nest, true, fn);
    }
    throw new Error('Invalid field type');
};
exports.resolveValueFieldType = resolveValueFieldType;
const isExtensionNode = (t) => !![
    Models_1.TypeExtension.EnumTypeExtension,
    Models_1.TypeExtension.InputObjectTypeExtension,
    Models_1.TypeExtension.InterfaceTypeExtension,
    Models_1.TypeExtension.ObjectTypeExtension,
    Models_1.TypeExtension.ScalarTypeExtension,
    Models_1.TypeExtension.UnionTypeExtension,
].find((o) => o === t);
exports.isExtensionNode = isExtensionNode;
const regenerateId = (n) => {
    const id = (0, shared_1.generateNodeId)(n.name, n.data.type, n.args);
    n.id = id;
    return n;
};
exports.regenerateId = regenerateId;
const ChangeRelatedNode = ({ newName, node, oldName, }) => {
    const typeName = (0, shared_1.getTypeName)(node.type.fieldType);
    if (typeName === oldName) {
        (0, exports.changeTypeName)(node.type.fieldType, newName);
    }
    if (node.args) {
        node.args.forEach((n) => (0, exports.ChangeRelatedNode)({ oldName, newName, node: n }));
    }
    (0, exports.regenerateId)(node);
};
exports.ChangeRelatedNode = ChangeRelatedNode;
const ChangeAllRelatedNodes = ({ newName, nodes, oldName, }) => {
    nodes.forEach((n) => (0, exports.ChangeRelatedNode)({ oldName, newName, node: n }));
};
exports.ChangeAllRelatedNodes = ChangeAllRelatedNodes;
const RemoveRelatedExtensionNodes = ({ node, tree }) => {
    const { data: { type }, } = node;
    if (type === Models_1.TypeDefinition.EnumTypeDefinition ||
        type === Models_1.TypeDefinition.InputObjectTypeDefinition ||
        type === Models_1.TypeDefinition.InterfaceTypeDefinition ||
        type === Models_1.TypeDefinition.ObjectTypeDefinition ||
        type === Models_1.TypeDefinition.ScalarTypeDefinition ||
        type === Models_1.TypeDefinition.UnionTypeDefinition) {
        [...tree.nodes].forEach((n) => {
            if (n.name === node.name) {
                const nodeToBeRemoved = tree.nodes.findIndex((fn) => fn.id === n.id);
                tree.nodes.splice(nodeToBeRemoved, 1);
            }
        });
    }
};
exports.RemoveRelatedExtensionNodes = RemoveRelatedExtensionNodes;
const isScalarArgument = (field, scalarTypes) => {
    const typeName = (0, shared_1.getTypeName)(field.type.fieldType);
    if (typeName === Models_1.ScalarTypes.Boolean) {
        return true;
    }
    if (typeName === Models_1.ScalarTypes.Float) {
        return true;
    }
    if (typeName === Models_1.ScalarTypes.ID) {
        return true;
    }
    if (typeName === Models_1.ScalarTypes.Int) {
        return true;
    }
    if (typeName === Models_1.ScalarTypes.String) {
        return true;
    }
    return scalarTypes.includes(typeName);
};
exports.isScalarArgument = isScalarArgument;
const isArrayType = (f) => f.type === Models_1.Options.required ? f.nest.type === Models_1.Options.array : f.type === Models_1.Options.array;
exports.isArrayType = isArrayType;
