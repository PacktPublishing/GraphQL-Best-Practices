"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.changeInterfaceField = exports.updateInterfaceNodeAddField = exports._getAllConnectedInterfaces = exports._replaceField = exports._updateNodeByInterfaceAddField = void 0;
const Models_1 = require("../Models");
const shared_1 = require("../shared");
const shared_2 = require("./shared");
const _updateNodeByInterfaceAddField = (interfaceNode) => (node) => {
    interfaceNode.args.forEach((ia) => {
        const sameFieldInNode = node.args.findIndex((na) => na.name === ia.name);
        if (sameFieldInNode === -1) {
            node.args.push((0, shared_1.createParserField)(Object.assign(Object.assign({}, ia), { fromInterface: [interfaceNode.name] })));
            return;
        }
    });
};
exports._updateNodeByInterfaceAddField = _updateNodeByInterfaceAddField;
const _replaceField = (oldField, newField) => (node) => {
    const fieldToChange = node.args.findIndex((na) => na.name === oldField.name);
    const argToChange = node.args[fieldToChange];
    if (node.args[fieldToChange] && argToChange.fromInterface) {
        node.args[fieldToChange] = (0, shared_1.createParserField)(Object.assign(Object.assign({}, newField), { fromInterface: [...argToChange.fromInterface] }));
        (0, shared_2.regenerateId)(node.args[fieldToChange]);
        (0, shared_2.regenerateId)(node);
    }
};
exports._replaceField = _replaceField;
const _getAllConnectedInterfaces = (nodes, interfaces) => {
    const computedInterfaces = [];
    const computeConnectedInterfaces = (nodes, interfaces, interfacesToPush) => {
        const allInterfaces = nodes.filter((ni) => ni.data.type === Models_1.TypeDefinition.InterfaceTypeDefinition);
        interfacesToPush.push(...interfaces.filter((ii) => !interfacesToPush.includes(ii)));
        for (const i of interfaces) {
            const hasInterface = allInterfaces.find((interfaceObject) => interfaceObject.name === i);
            if ((hasInterface === null || hasInterface === void 0 ? void 0 : hasInterface.interfaces) && hasInterface.interfaces.length) {
                computeConnectedInterfaces(nodes, hasInterface.interfaces, interfacesToPush);
            }
        }
    };
    computeConnectedInterfaces(nodes, interfaces, computedInterfaces);
    return computedInterfaces;
};
exports._getAllConnectedInterfaces = _getAllConnectedInterfaces;
const updateInterfaceNodeAddField = (nodes, interfaceNode) => {
    const updateWithInterface = (0, exports._updateNodeByInterfaceAddField)(interfaceNode);
    nodes.filter((n) => n.interfaces.includes(interfaceNode.name)).forEach(updateWithInterface);
};
exports.updateInterfaceNodeAddField = updateInterfaceNodeAddField;
const changeInterfaceField = (nodes, interfaceNode, oldField, newField) => {
    const updateWithOldField = (0, exports._replaceField)(oldField, newField);
    nodes.filter((n) => n.interfaces.includes(interfaceNode.name)).forEach(updateWithOldField);
};
exports.changeInterfaceField = changeInterfaceField;
