"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeSDLs = exports.mergeTrees = void 0;
const Models_1 = require("../Models");
const Parser_1 = require("../Parser");
const shared_1 = require("./shared");
const TreeToGraphQL_1 = require("../TreeToGraphQL");
const shared_2 = require("../shared");
const addFromLibrary = (n) => (Object.assign(Object.assign({}, n), { fromLibrary: true }));
const mergeNode = (n1, n2) => {
    const args = [...n1.args, ...n2.args.map(addFromLibrary)];
    const mergedNode = Object.assign(Object.assign({}, n1), { id: (0, shared_2.generateNodeId)(n1.name, n1.data.type, args), args, directives: [...n1.directives, ...n2.directives.map(addFromLibrary)], interfaces: [...n1.interfaces, ...n2.interfaces] });
    mergedNode.args = mergedNode.args.filter((a, i) => mergedNode.args.findIndex((aa) => aa.name === a.name) === i);
    mergedNode.directives = mergedNode.directives.filter((a, i) => mergedNode.directives.findIndex((aa) => aa.name === a.name) === i);
    mergedNode.interfaces = mergedNode.interfaces.filter((a, i) => mergedNode.interfaces.findIndex((aa) => aa === a) === i);
    return mergedNode;
};
const mergeTrees = (tree1, tree2) => {
    const mergedNodesT1 = [];
    const mergedNodesT2 = [];
    const mergeResultNodes = [];
    const errors = [];
    const filteredTree2Nodes = tree2.nodes.filter((t) => t.data.type !== Models_1.TypeSystemDefinition.SchemaDefinition);
    tree1.nodes.forEach((t1n) => {
        const matchingNode = filteredTree2Nodes.find((t2n) => t2n.name === t1n.name && t1n.data.type === t2n.data.type);
        if (matchingNode) {
            if ((0, shared_1.isExtensionNode)(matchingNode.data.type)) {
                t1n.args.forEach((t1nA) => {
                    const matchingArg = matchingNode.args.find((mNA) => mNA.name === t1nA.name);
                    if (matchingArg) {
                        if (JSON.stringify(matchingArg) !== JSON.stringify(t1nA)) {
                            errors.push({
                                conflictingField: t1nA.name,
                                conflictingNode: t1n.name,
                            });
                        }
                    }
                });
            }
            else {
                mergedNodesT1.push(t1n);
                mergedNodesT2.push(matchingNode);
                t1n.args.forEach((t1nA) => {
                    const matchingArg = matchingNode.args.find((mNA) => mNA.name === t1nA.name);
                    if (matchingArg) {
                        if (JSON.stringify(matchingArg) !== JSON.stringify(t1nA)) {
                            errors.push({
                                conflictingField: t1nA.name,
                                conflictingNode: t1n.name,
                            });
                        }
                    }
                });
                if (!errors.length) {
                    mergeResultNodes.push(mergeNode(t1n, matchingNode));
                }
            }
        }
    });
    if (errors.length) {
        return {
            __typename: 'error',
            errors,
        };
    }
    const t1Nodes = tree1.nodes.filter((t1n) => !mergedNodesT1.find((mtn1) => mtn1 === t1n));
    const t2Nodes = filteredTree2Nodes
        .filter((t2n) => !mergedNodesT2.find((mtn2) => mtn2 === t2n))
        .map((n) => (Object.assign(Object.assign({}, n), { fromLibrary: true })));
    return {
        __typename: 'success',
        nodes: [...t1Nodes, ...mergeResultNodes, ...t2Nodes],
    };
};
exports.mergeTrees = mergeTrees;
const mergeSDLs = (sdl1, sdl2) => {
    const t1 = Parser_1.Parser.parse(sdl1);
    const t2 = Parser_1.Parser.parse(sdl2);
    const mergeResult = (0, exports.mergeTrees)(t1, {
        nodes: t2.nodes.filter((n) => n.data.type !== Models_1.TypeSystemDefinition.SchemaDefinition),
    });
    if (mergeResult.__typename === 'success') {
        const sdl = TreeToGraphQL_1.TreeToGraphQL.parse(mergeResult);
        return Object.assign(Object.assign({}, mergeResult), { sdl });
    }
    return mergeResult;
};
exports.mergeSDLs = mergeSDLs;
