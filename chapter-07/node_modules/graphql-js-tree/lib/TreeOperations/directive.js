"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recursivelyDeleteDirectiveArgument = exports.recursivelyUpdateDirectiveArgument = exports.recursivelyRenameDirectiveNodes = exports.recursivelyDeleteAllDirectiveNodes = exports.recursivelyDeleteDirectiveNodes = void 0;
const Models_1 = require("../Models");
const tree_1 = require("./tree");
const recursivelyDeleteDirectiveNodes = (nodes, directiveName) => {
    nodes.forEach((n) => {
        if (n.directives) {
            n.directives = n.directives.filter((d) => d.name !== directiveName);
        }
        (0, exports.recursivelyDeleteDirectiveNodes)(n.args, directiveName);
    });
};
exports.recursivelyDeleteDirectiveNodes = recursivelyDeleteDirectiveNodes;
const recursivelyDeleteAllDirectiveNodes = (nodes) => {
    const indexesToRemove = [];
    nodes.forEach((n, i) => {
        if (n.data.type === Models_1.TypeSystemDefinition.DirectiveDefinition) {
            indexesToRemove.push(i);
        }
        if (n.directives) {
            n.directives = [];
        }
        (0, exports.recursivelyDeleteAllDirectiveNodes)(n.args);
    });
    indexesToRemove.reverse();
    indexesToRemove.forEach((itr) => {
        nodes.splice(itr, 1);
    });
};
exports.recursivelyDeleteAllDirectiveNodes = recursivelyDeleteAllDirectiveNodes;
const recursivelyRenameDirectiveNodes = (nodes, oldDirectiveName, newDirectiveName) => {
    nodes.forEach((n) => {
        if (n.directives) {
            n.directives = n.directives.map((d) => d.name !== oldDirectiveName
                ? d
                : Object.assign(Object.assign({}, d), { name: newDirectiveName, type: {
                        fieldType: {
                            name: newDirectiveName,
                            type: Models_1.Options.name,
                        },
                    } }));
        }
        (0, exports.recursivelyRenameDirectiveNodes)(n.args, oldDirectiveName, newDirectiveName);
    });
};
exports.recursivelyRenameDirectiveNodes = recursivelyRenameDirectiveNodes;
const recursivelyUpdateDirectiveArgument = (nodes, directiveName, oldField, newField, allNodes) => {
    nodes.forEach((n) => {
        if (n.directives.length > 0) {
            const remappedDirectives = n.directives.map((d) => {
                if (d.name !== directiveName)
                    return d;
                const remappedArgs = d.args.map((a) => {
                    var _a;
                    return a.name === oldField.name
                        ? Object.assign(Object.assign({}, a), { name: newField.name, value: {
                                value: (_a = a.value) === null || _a === void 0 ? void 0 : _a.value,
                                type: (0, tree_1.checkValueType)(newField, allNodes),
                            }, type: {
                                fieldType: Object.assign(Object.assign({}, a.type.fieldType), { name: newField.name }),
                            } }) : a;
                });
                return Object.assign(Object.assign({}, d), { args: remappedArgs });
            });
            n.directives = remappedDirectives;
        }
        (0, exports.recursivelyUpdateDirectiveArgument)(n.args, directiveName, oldField, newField, allNodes);
    });
};
exports.recursivelyUpdateDirectiveArgument = recursivelyUpdateDirectiveArgument;
const recursivelyDeleteDirectiveArgument = (nodes, directiveName, argumentField) => {
    nodes.forEach((n) => {
        if (n.directives) {
            n.directives = n.directives.map((d) => d.name !== directiveName
                ? d
                : Object.assign(Object.assign({}, d), { args: d.args.filter((a) => a.name !== argumentField.name) }));
        }
        (0, exports.recursivelyDeleteDirectiveArgument)(n.args, directiveName, argumentField);
    });
};
exports.recursivelyDeleteDirectiveArgument = recursivelyDeleteDirectiveArgument;
