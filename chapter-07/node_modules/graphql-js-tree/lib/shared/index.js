"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSchemaExtension = exports.createSchemaDefinition = exports.compareParserFields = exports.createPlainArgument = exports.createPlainDirectiveImplementation = exports.createUnionMember = exports.createPlainEnumValue = exports.createPlainInputValue = exports.createTypeNameField = exports.createPlainField = exports.createRootDirectiveField = exports.createRootExtensionField = exports.createRootField = exports.createParserField = exports.generateNodeId = exports.decompileType = exports.compileType = exports.getTypeName = void 0;
const Models_1 = require("../Models");
const shared_1 = require("../TreeOperations/shared");
const getTypeName = (f) => {
    if (f.type === Models_1.Options.name) {
        return f.name;
    }
    return (0, exports.getTypeName)(f.nest);
};
exports.getTypeName = getTypeName;
const compileType = (f) => {
    if (f.type === Models_1.Options.array) {
        return `[${(0, exports.compileType)(f.nest)}]`;
    }
    if (f.type === Models_1.Options.required) {
        return `${(0, exports.compileType)(f.nest)}!`;
    }
    return f.name;
};
exports.compileType = compileType;
const decompileType = (typeName) => {
    const arrayType = typeName.endsWith(']');
    const requiredType = typeName.endsWith('!');
    if (arrayType) {
        return {
            type: Models_1.Options.array,
            nest: (0, exports.decompileType)(typeName.substring(1, typeName.length - 1)),
        };
    }
    if (requiredType) {
        return {
            type: Models_1.Options.required,
            nest: (0, exports.decompileType)(typeName.substring(0, typeName.length - 1)),
        };
    }
    return {
        type: Models_1.Options.name,
        name: typeName,
    };
};
exports.decompileType = decompileType;
const generateNodeId = (name, dataType, args) => {
    const s = (0, shared_1.isExtensionNode)(dataType)
        ? `${name}-extend-${cyrb53(JSON.stringify(args.map((a) => a.name + a.id)))}`
        : name;
    return s;
};
exports.generateNodeId = generateNodeId;
const cyrb53 = (str, seed = 0) => {
    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString(16);
};
const createParserField = (props) => {
    return Object.assign({ args: [], directives: [], interfaces: [], id: (0, exports.generateNodeId)(props.name, props.data.type, props.args || []) }, props);
};
exports.createParserField = createParserField;
const createRootField = (_a) => {
    var { name, type } = _a, props = __rest(_a, ["name", "type"]);
    return (0, exports.createParserField)(Object.assign(Object.assign({}, props), { name, data: {
            type,
        }, type: {
            fieldType: {
                name: Models_1.TypeDefinitionDisplayMap[type],
                type: Models_1.Options.name,
            },
        } }));
};
exports.createRootField = createRootField;
const createRootExtensionField = (_a) => {
    var { name, type } = _a, props = __rest(_a, ["name", "type"]);
    return (0, exports.createParserField)(Object.assign(Object.assign({}, props), { name, data: {
            type,
        }, type: {
            fieldType: {
                name: Models_1.TypeDefinitionDisplayMap[type],
                type: Models_1.Options.name,
            },
        } }));
};
exports.createRootExtensionField = createRootExtensionField;
const createRootDirectiveField = (_a) => {
    var { name, directiveOptions = [Models_1.Directive.OBJECT] } = _a, props = __rest(_a, ["name", "directiveOptions"]);
    return (0, exports.createParserField)(Object.assign(Object.assign({}, props), { name, data: {
            type: Models_1.TypeSystemDefinition.DirectiveDefinition,
        }, type: {
            fieldType: {
                name: Models_1.TypeDefinitionDisplayMap[Models_1.TypeSystemDefinition.DirectiveDefinition],
                type: Models_1.Options.name,
            },
            directiveOptions,
        } }));
};
exports.createRootDirectiveField = createRootDirectiveField;
const createPlainField = (_a) => {
    var { name, type } = _a, props = __rest(_a, ["name", "type"]);
    return (0, exports.createParserField)(Object.assign(Object.assign({}, props), { name, data: {
            type: Models_1.TypeSystemDefinition.FieldDefinition,
        }, type: {
            fieldType: {
                name: type,
                type: Models_1.Options.name,
            },
        } }));
};
exports.createPlainField = createPlainField;
const createTypeNameField = () => {
    return (0, exports.createParserField)({
        name: '__typename',
        description: 'The name of the current Object type at runtime.',
        data: {
            type: Models_1.TypeSystemDefinition.FieldDefinition,
        },
        type: {
            fieldType: {
                type: Models_1.Options.required,
                nest: {
                    type: Models_1.Options.name,
                    name: Models_1.ScalarTypes.String,
                },
            },
        },
    });
};
exports.createTypeNameField = createTypeNameField;
const createPlainInputValue = (_a) => {
    var { name, type } = _a, props = __rest(_a, ["name", "type"]);
    return (0, exports.createParserField)(Object.assign(Object.assign({}, props), { name, data: {
            type: Models_1.ValueDefinition.InputValueDefinition,
        }, type: {
            fieldType: {
                name: type,
                type: Models_1.Options.name,
            },
        } }));
};
exports.createPlainInputValue = createPlainInputValue;
const createPlainEnumValue = (_a) => {
    var { name } = _a, props = __rest(_a, ["name"]);
    return (0, exports.createParserField)(Object.assign(Object.assign({}, props), { name, data: {
            type: Models_1.ValueDefinition.EnumValueDefinition,
        }, type: {
            fieldType: {
                name: Models_1.ValueDefinition.EnumValueDefinition,
                type: Models_1.Options.name,
            },
        } }));
};
exports.createPlainEnumValue = createPlainEnumValue;
const createUnionMember = (_a) => {
    var { name } = _a, props = __rest(_a, ["name"]);
    return (0, exports.createParserField)(Object.assign(Object.assign({}, props), { name, data: {
            type: Models_1.TypeSystemDefinition.UnionMemberDefinition,
        }, type: {
            fieldType: {
                name,
                type: Models_1.Options.name,
            },
        } }));
};
exports.createUnionMember = createUnionMember;
const createPlainDirectiveImplementation = (_a) => {
    var { name } = _a, props = __rest(_a, ["name"]);
    return (0, exports.createParserField)(Object.assign(Object.assign({}, props), { name, data: {
            type: Models_1.Instances.Directive,
        }, type: {
            fieldType: {
                name,
                type: Models_1.Options.name,
            },
        } }));
};
exports.createPlainDirectiveImplementation = createPlainDirectiveImplementation;
const createPlainArgument = (_a) => {
    var { name } = _a, props = __rest(_a, ["name"]);
    return (0, exports.createParserField)(Object.assign(Object.assign({}, props), { name, data: {
            type: Models_1.Instances.Argument,
        }, type: {
            fieldType: {
                name,
                type: Models_1.Options.name,
            },
        } }));
};
exports.createPlainArgument = createPlainArgument;
const compareParserFields = (f1) => (f2) => f1.id === f2.id;
exports.compareParserFields = compareParserFields;
const createSchemaDefinition = (options) => {
    return (0, exports.createParserField)({
        name: 'schema',
        data: {
            type: Models_1.TypeSystemDefinition.SchemaDefinition,
        },
        type: {
            fieldType: {
                type: Models_1.Options.name,
                name: 'schema',
            },
        },
        directives: (options === null || options === void 0 ? void 0 : options.directives) || [],
        args: (options === null || options === void 0 ? void 0 : options.operations)
            ? Object.entries(options === null || options === void 0 ? void 0 : options.operations)
                .filter(([, v]) => !!v)
                .map(([k, v]) => (0, exports.createParserField)({
                name: k,
                data: {
                    type: Models_1.TypeSystemDefinition.FieldDefinition,
                },
                type: {
                    fieldType: {
                        type: Models_1.Options.name,
                        name: v,
                    },
                },
            }))
            : [],
    });
};
exports.createSchemaDefinition = createSchemaDefinition;
const createSchemaExtension = (options) => {
    return (0, exports.createParserField)({
        name: 'schema',
        data: {
            type: Models_1.TypeSystemExtension.SchemaExtension,
        },
        directives: (options === null || options === void 0 ? void 0 : options.directives) || [],
        type: {
            fieldType: {
                type: Models_1.Options.name,
                name: 'schema',
            },
        },
        args: (options === null || options === void 0 ? void 0 : options.operations)
            ? Object.entries(options === null || options === void 0 ? void 0 : options.operations)
                .filter(([, v]) => !!v)
                .map(([k, v]) => (0, exports.createParserField)({
                name: k,
                data: {
                    type: Models_1.TypeSystemDefinition.FieldDefinition,
                },
                type: {
                    fieldType: {
                        type: Models_1.Options.name,
                        name: v,
                    },
                },
            }))
            : [],
    });
};
exports.createSchemaExtension = createSchemaExtension;
